// Algorithm 
// 1. Edge loop
//     For each triangle edge:
//         Compute midpoint
//         Project midpoint to blade -> (d, xb)
//         Compute desired length h(d,xb)
//         If edge_length > C * h, flag edge
// 2. Cell classification
//     For each triangle:
//         1 edge -> bisect opposite vertex
//         2 edges -> split larger angle 
//         3 edges -> subdivide into 4
// 3. Refine 
//     Insert new nodes at flagged edge midpoints
//     Update connectivity

// 4. Snap boundary nodes
//     If new node lies on blade boundary: 
//         Project to blade curve
//         Replace coordinates with xb

// 5. Smoothing
//     Apply: tild_{x[i]}=(1-w)*x[i]+w/abs(N[i])*sum(x[j])
//     Skip boundary nodes

// src/mesh/LocalRefinement.cpp

#include "mesh/LocalRefinement.h"
#include "mesh/Projection2D.h"
#include "mesh/SizingFunction.h"
#include "mesh/BladeGeometry.h"
#include "mesh/Projection2D.h"    // for Projection2D + projection funcs

#include <unordered_map>
#include <vector>
#include <algorithm>
#include <cmath>
#include <stdexcept>
#include <iostream>
#include <Eigen/Dense>

namespace mesh {

//==============================================================
// Smoothing Helpers
//==============================================================
static void buildAdjacency(const Eigen::MatrixXi& E,
                           int Nn,
                           std::vector<std::vector<int>>& nbrs)
{
    nbrs.assign(Nn, {});
    nbrs.reserve(Nn);

    auto addEdge = [&](int a, int b){
        nbrs[a].push_back(b);
        nbrs[b].push_back(a);
    };

    for (int t=0; t<E.rows(); ++t) {
        const int i0 = E(t,0), i1 = E(t,1), i2 = E(t,2);
        addEdge(i0,i1);
        addEdge(i1,i2);
        addEdge(i2,i0);
    }

    // unique neighbors
    for (auto& v : nbrs) {
        std::sort(v.begin(), v.end());
        v.erase(std::unique(v.begin(), v.end()), v.end());
    }
}

static void markBoundaryNodes(const std::vector<mesh::GriBoundaryBlock>& B,
                              int Nn,
                              std::vector<char>& isBnd)
{
    isBnd.assign(Nn, 0);
    for (const auto& blk : B) {
        for (int r=0; r<blk.edges.rows(); ++r) {
            isBnd[ blk.edges(r,0) ] = 1;
            isBnd[ blk.edges(r,1) ] = 1;
        }
    }
}

static void smoothInterior(mesh::GriMesh2D& mesh,
                           int smoothIters,
                           double omega)
{
    omega = std::clamp(omega, 0.0, 1.0);
    if (smoothIters <= 0 || omega == 0.0) return;

    const int Nn = (int)mesh.V.rows();

    std::vector<std::vector<int>> nbrs;
    buildAdjacency(mesh.E, Nn, nbrs);

    std::vector<char> isBnd;
    markBoundaryNodes(mesh.B, Nn, isBnd);

    Eigen::MatrixXd Vold = mesh.V;
    Eigen::MatrixXd Vnew = mesh.V;

    for (int it=0; it<smoothIters; ++it) {
        Vnew = Vold;

        for (int i=0; i<Nn; ++i) {
            if (isBnd[i]) continue;               // no boundary smoothing
            const auto& Ni = nbrs[i];
            if (Ni.empty()) continue;

            Eigen::Vector2d avg(0.0, 0.0);
            for (int j : Ni) avg += Vold.row(j).transpose();
            avg /= double(Ni.size());

            Eigen::Vector2d xi = Vold.row(i).transpose();
            Eigen::Vector2d xip = (1.0 - omega)*xi + omega*avg;

            Vnew(i,0) = xip.x();
            Vnew(i,1) = xip.y();
        }

        Vold.swap(Vnew);
    }

    mesh.V = Vold;
}

//==============================================================
// Configuration (match your Curtis reference)
//==============================================================
// The lower spline is conceptually offset by +13 in y for distance evaluation,
// as in the provided Python reference.
static constexpr double kLowerYOffset = 13.1;

//==============================================================
// Types / utilities
//==============================================================
enum class BladeBlockType { None=0, Upper=1, Lower=2 };

struct EdgeKey {
    int a, b; // a < b
    bool operator==(const EdgeKey& o) const { return a==o.a && b==o.b; }
};

struct EdgeKeyHash {
    std::size_t operator()(const EdgeKey& e) const noexcept {
        return (static_cast<std::size_t>(e.a) << 32) ^ static_cast<std::size_t>(e.b);
    }
};

static inline EdgeKey makeEdge(int i, int j) {
    return (i < j) ? EdgeKey{i,j} : EdgeKey{j,i};
}

static inline double edgeLen2D(const Eigen::MatrixXd& V, int a, int b) {
    const double dx = V(a,0) - V(b,0);
    const double dy = V(a,1) - V(b,1);
    return std::sqrt(dx*dx + dy*dy);
}

//==============================================================
// Periodic projection helpers
//==============================================================

// Project to a forced curve (upper or lower), considering y-periodic images (0, ±Ly).
static ProjectionResult projectToBladePeriodicYForced(
    const Projection2D& projector,
    const BladeGeometry& blade,
    const Eigen::Vector2d& p,
    double Ly,
    int curveId // 0=upper, 1=lower
){
    std::vector<Eigen::Vector2d> shifts;
    shifts.reserve(9);

    // Always consider periodic images
    shifts.push_back({0.0, 0.0});
    shifts.push_back({0.0, +Ly});
    shifts.push_back({0.0, -Ly});

    // If your mesh contains a *shifted* copy of the lower blade inside the same cell,
    // include that family too (this matches your refinement-distance trick).
    if (curveId == 1) {
        const double y0 = kLowerYOffset; // <-- your existing constant (13 or 18)
        shifts.push_back({0.0, +y0});
        shifts.push_back({0.0, +y0 + Ly});
        shifts.push_back({0.0, +y0 - Ly});

        shifts.push_back({0.0, -y0});
        shifts.push_back({0.0, -y0 + Ly});
        shifts.push_back({0.0, -y0 - Ly});
    }

    ProjectionResult best;
    best.dist2   = 1e300;
    best.curveId = curveId;

    for (const auto& s : shifts) {
        const Eigen::Vector2d q = p + s;

        ProjectionResult r = (curveId == 0)
            ? projector.projectToUpper(blade, q)
            : projector.projectToLower(blade, q);

        // map projection back to original cell
        r.xProj -= s;

        const Eigen::Vector2d diff = r.xProj - p;
        r.dist2 = diff.squaredNorm();
        r.dist  = std::sqrt(r.dist2);

        if (r.dist2 < best.dist2) best = r;
    }

    return best;
}


// Distance projection that matches Curtis-style logic:
// candidates = upper with (0,±Ly) and lower with (+kLowerYOffset, ±Ly) shifts.
static ProjectionResult projectToBladeTwoPeriodicY_WithLowerShift(
    const Projection2D& projector,
    const BladeGeometry& blade,
    const Eigen::Vector2d& p,
    double Ly,
    double dYblade
){
    const double shiftsY[3] = {0.0, +Ly, -Ly};

    ProjectionResult best;
    best.dist2 = 1e300;

    // Upper images: q = p + (0, shiftY)
    for (int k=0; k<3; ++k) {
        const Eigen::Vector2d shift(0.0, shiftsY[k]);
        const Eigen::Vector2d q = p + shift;

        ProjectionResult r = projector.projectToUpper(blade, q);

        r.xProj -= shift;
        const Eigen::Vector2d diff = r.xProj - p;
        r.dist2 = diff.squaredNorm();
        r.dist  = std::sqrt(r.dist2);

        if (r.dist2 < best.dist2) best = r;
    }

    // Lower images (shifted): q = p + (0, dYblade + shiftY)
    for (int k=0; k<3; ++k) {
        const Eigen::Vector2d shift(0.0, dYblade + shiftsY[k]);
        const Eigen::Vector2d q = p + shift;

        ProjectionResult r = projector.projectToLower(blade, q);

        r.xProj -= shift;
        const Eigen::Vector2d diff = r.xProj - p;
        r.dist2 = diff.squaredNorm();
        r.dist  = std::sqrt(r.dist2);

        if (r.dist2 < best.dist2) best = r;
    }

    return best;
}

ProjectionResult LocalRefinement::projectDistance(
    const Eigen::Vector2d& p,
    const Eigen::MatrixXd& V,
    const BladeGeometry& blade,
    const Projection2D& projector
){
    const double yMin = V.col(1).minCoeff();
    const double yMax = V.col(1).maxCoeff();
    const double Ly   = yMax - yMin;

    return projectToBladeTwoPeriodicY_WithLowerShift(projector, blade, p, Ly, kLowerYOffset);
}


static ProjectionResult projectToBladePeriodicYForced_WithLowerYOffset(
    const Projection2D& projector,
    const BladeGeometry& blade,
    const Eigen::Vector2d& p,
    double Ly,
    int curveId,            // 0=upper, 1=lower
    double lowerYOffset     // e.g. kLowerYOffset
){
    // For LOWER: shift the query point up by lowerYOffset, project, then shift result back down.
    if (curveId == 1) {
        Eigen::Vector2d ps = p;
        ps.y() += lowerYOffset;

        auto r = projectToBladePeriodicYForced(projector, blade, ps, Ly, 1);
        r.xProj.y() -= lowerYOffset;

        // recompute distance against original p
        const Eigen::Vector2d diff = r.xProj - p;
        r.dist2 = diff.squaredNorm();
        r.dist  = std::sqrt(r.dist2);
        return r;
    }

    // Upper: unchanged
    return projectToBladePeriodicYForced(projector, blade, p, Ly, 0);
}

//==============================================================
// Boundary classification (for snapping midpoints on blade blocks)
//==============================================================
// IMPORTANT: This classification is for the *actual* blade boundary blocks,
// so it uses forced projections to upper/lower WITHOUT the +18 lower-offset.
static BladeBlockType classifyBladeBoundaryBlock(
    const Eigen::MatrixXd& V,
    const Eigen::MatrixXi& edges,
    const BladeGeometry& blade,
    const Projection2D& projector,
    double Ly,
    double tol = 1e-4,
    double fracMin = 0.2,
    int maxTest = 200
){
    // collect unique node ids from the block
    std::vector<int> ids;
    ids.reserve(edges.rows()*2);
    for (int i=0; i<edges.rows(); ++i) {
        ids.push_back(edges(i,0));
        ids.push_back(edges(i,1));
    }
    std::sort(ids.begin(), ids.end());
    ids.erase(std::unique(ids.begin(), ids.end()), ids.end());

    const int nAll  = (int)ids.size();
    const int nTest = std::min(maxTest, nAll);

    int nCloseU = 0, nCloseL = 0;

    for (int k=0; k<nTest; ++k) {
        const int idx = (int)std::floor( (double)k * (nAll-1) / std::max(1, nTest-1) );
        const int id = ids[idx];
        const Eigen::Vector2d p(V(id,0), V(id,1));

        const ProjectionResult ru =
            projectToBladePeriodicYForced_WithLowerYOffset(projector, blade, p, Ly, 0, kLowerYOffset);
        const ProjectionResult rl =
            projectToBladePeriodicYForced_WithLowerYOffset(projector, blade, p, Ly, 1, kLowerYOffset);

        if (ru.dist < tol) ++nCloseU;
        if (rl.dist < tol) ++nCloseL;
    }

    const double fU = (nTest>0) ? double(nCloseU)/double(nTest) : 0.0;
    const double fL = (nTest>0) ? double(nCloseL)/double(nTest) : 0.0;

    if (fU >= fracMin) return BladeBlockType::Upper;
    if (fL >= fracMin) return BladeBlockType::Lower;
    return BladeBlockType::None;
}


//==============================================================
// Enforce snapping of blade boundary nodes
//==============================================================
static void snapBladeBoundaries(mesh::GriMesh2D& mesh,
                                const mesh::BladeGeometry& blade,
                                const mesh::Projection2D& projector,
                                double Ly)
{
    std::vector<char> snapped(mesh.V.rows(), 0);

    for (auto& blk : mesh.B) {
        const mesh::BladeBlockType btype =
            classifyBladeBoundaryBlock(mesh.V, blk.edges, blade, projector, Ly);

        if (btype == mesh::BladeBlockType::None) continue;

        // snap unique nodes of this block
        std::vector<int> ids;
        ids.reserve(blk.edges.rows()*2);
        for (int r=0; r<blk.edges.rows(); ++r) {
            ids.push_back(blk.edges(r,0));
            ids.push_back(blk.edges(r,1));
        }
        std::sort(ids.begin(), ids.end());
        ids.erase(std::unique(ids.begin(), ids.end()), ids.end());

        for (int id : ids) {
            if (snapped[id]) continue;

            const Eigen::Vector2d p(mesh.V(id,0), mesh.V(id,1));

            const auto ru =
                projectToBladePeriodicYForced_WithLowerYOffset(projector, blade, p, Ly, 0, kLowerYOffset);
            const auto rl =
                projectToBladePeriodicYForced_WithLowerYOffset(projector, blade, p, Ly, 1, kLowerYOffset);

            const auto& best = (ru.dist <= rl.dist) ? ru : rl;
            mesh.V(id,0) = best.xProj.x();
            mesh.V(id,1) = best.xProj.y();

            snapped[id] = 1;
        }

    }
}

// Module for debugging / verification of blade snapping
static void verifyBladeSnap(const mesh::GriMesh2D& mesh,
                            const mesh::BladeGeometry& blade,
                            const mesh::Projection2D& projector,
                            double Ly,
                            double tol)
{
    for (const auto& blk : mesh.B) {
        const auto btype = classifyBladeBoundaryBlock(mesh.V, blk.edges, blade, projector, Ly);
        if (btype == mesh::BladeBlockType::None) continue;

        const int forceId = (btype == mesh::BladeBlockType::Upper) ? 0 : 1;

        // unique node ids
        std::vector<int> ids;
        ids.reserve(blk.edges.rows()*2);
        for (int r=0; r<blk.edges.rows(); ++r) {
            ids.push_back(blk.edges(r,0));
            ids.push_back(blk.edges(r,1));
        }
        std::sort(ids.begin(), ids.end());
        ids.erase(std::unique(ids.begin(), ids.end()), ids.end());

        double rmax = 0.0, rsum = 0.0;
        int nbad = 0;

        for (int id : ids) {
            Eigen::Vector2d p(mesh.V(id,0), mesh.V(id,1));
            auto proj = projectToBladePeriodicYForced(projector, blade, p, Ly, forceId);

            double r = (p - proj.xProj).norm();   // geometric residual
            rmax = std::max(rmax, r);
            rsum += r;
            if (r > tol) ++nbad;
        }

        std::cout << "[VERIFY SNAP] blk=" << blk.name
                  << " type=" << ((forceId==0)?"Upper":"Lower")
                  << " N=" << ids.size()
                  << " rmax=" << rmax
                  << " ravg=" << (rsum/std::max<size_t>(1,ids.size()))
                  << " nbad(>"<<tol<<")=" << nbad
                  << "\n";
    }
}

// Debuging helper to check blade boundary snapping start
static void assertBladeBlocksPresent(const mesh::GriMesh2D& mesh,
                                     const mesh::BladeGeometry& blade,
                                     const mesh::Projection2D& projector,
                                     double Ly)
{
    bool foundUpper = false;
    bool foundLower = false;

    for (const auto& blk : mesh.B) {
        const auto btype =
            classifyBladeBoundaryBlock(mesh.V, blk.edges, blade, projector, Ly);

        if (btype == mesh::BladeBlockType::Upper) foundUpper = true;
        if (btype == mesh::BladeBlockType::Lower) foundLower = true;
    }

    if (!(foundUpper || foundLower)) {
        std::cerr << "[FATAL] No blade boundary blocks detected.\n";
        throw std::runtime_error("Blade boundary classification failure");
    }

}

static void assertBladeSnapOK(const mesh::GriMesh2D& mesh,
                              const mesh::BladeGeometry& blade,
                              const mesh::Projection2D& projector,
                              double Ly,
                              double tol = 1e-10)
{
    for (const auto& blk : mesh.B) {
        const auto btype =
            classifyBladeBoundaryBlock(mesh.V, blk.edges, blade, projector, Ly);

        if (btype == mesh::BladeBlockType::None) continue;

        // collect unique nodes
        std::vector<int> ids;
        ids.reserve(blk.edges.rows()*2);
        for (int r=0; r<blk.edges.rows(); ++r) {
            ids.push_back(blk.edges(r,0));
            ids.push_back(blk.edges(r,1));
        }
        std::sort(ids.begin(), ids.end());
        ids.erase(std::unique(ids.begin(), ids.end()), ids.end());

        const int forceId = (btype == mesh::BladeBlockType::Upper) ? 0 : 1;

        double rmax = 0.0;
        int nbad = 0;

        for (int id : ids) {
            const Eigen::Vector2d p(mesh.V(id,0), mesh.V(id,1));
            const auto pr = projectToBladePeriodicYForced(projector, blade, p, Ly, forceId);
            rmax = std::max(rmax, pr.dist);
            if (pr.dist > tol) ++nbad;
        }

        if (nbad > 0) {
            std::cerr << "[FATAL] Blade snap failed on block " << blk.name
                      << " type=" << ((forceId==0) ? "Upper" : "Lower")
                      << " nbad=" << nbad << " rmax=" << rmax
                      << " tol=" << tol << "\n";
            throw std::runtime_error("Blade snapping failure");
        }
    }
}
// Debuging helper to check blade boundary snapping end

//==============================================================
// LocalRefinement methods
//==============================================================
void LocalRefinement::computeNodeDistanceAndSize(
    const Eigen::MatrixXd& V,
    const BladeGeometry& blade,
    const Projection2D& projector,
    const SizingFunction& sizeFun,
    Eigen::VectorXd& distOut,
    Eigen::VectorXd& hOut
){
    const int Nn = static_cast<int>(V.rows());
    distOut.resize(Nn);
    hOut.resize(Nn);

    const double yMin = V.col(1).minCoeff();
    const double yMax = V.col(1).maxCoeff();
    const double Ly   = yMax - yMin;

    for (int i = 0; i < Nn; ++i) {
        const Eigen::Vector2d p(V(i,0), V(i,1));

        // Distance field: upper periodic + lower(+18) periodic
        const auto res = projectToBladeTwoPeriodicY_WithLowerShift(
            projector, blade, p, Ly, kLowerYOffset
        );

        distOut(i) = res.dist;
        hOut(i)    = sizeFun(res.dist, res.xProj.x());
    }
}

void LocalRefinement::markElementsForRefinement(
    const Eigen::MatrixXd& V,
    const Eigen::MatrixXi& E,
    const Eigen::VectorXd& hNode,
    double alpha,
    std::vector<char>& refineFlag
){
    const int Ne = static_cast<int>(E.rows());
    refineFlag.assign(Ne, 0);

    for (int e = 0; e < Ne; ++e) {
        const int i0 = E(e,0), i1 = E(e,1), i2 = E(e,2);

        const double l01 = edgeLen2D(V, i0, i1);
        const double l12 = edgeLen2D(V, i1, i2);
        const double l20 = edgeLen2D(V, i2, i0);
        const double hCur = std::max(l01, std::max(l12, l20));

        const double hTar = std::min(hNode(i0), std::min(hNode(i1), hNode(i2)));

        if (hCur > alpha * hTar) refineFlag[e] = 1;
    }
}

//==============================================================
// LocalRefinement ::refineMesh
//==============================================================
GriMesh2D LocalRefinement::refineMesh(
    const GriMesh2D& meshIn,
    const BladeGeometry& blade,
    const Projection2D& projector,
    const SizingFunction& sizeFun,
    double alpha,
    int maxIters
){
    GriMesh2D mesh = meshIn;
    const int smoothIters = 10;    // try 10–30
    const double omega    = 0.5;   // 0.3–0.7 typical

    // NOTE: If refinement changes y-range, recompute Ly each iteration.
    // For your current usage, mesh y-range should remain stable.
    for (int it = 0; it < maxIters; ++it) {

        const double yMin = mesh.V.col(1).minCoeff();
        const double yMax = mesh.V.col(1).maxCoeff();
        const double Ly   = yMax - yMin;

        // 1) Build edge -> incident triangles adjacency
        std::unordered_map<EdgeKey, std::vector<int>, EdgeKeyHash> edge2tri;
        edge2tri.reserve(mesh.E.rows()*2);

        const int Ne = static_cast<int>(mesh.E.rows());
        for (int t=0; t<Ne; ++t) {
            const int i0 = mesh.E(t,0), i1 = mesh.E(t,1), i2 = mesh.E(t,2);
            edge2tri[makeEdge(i0,i1)].push_back(t);
            edge2tri[makeEdge(i1,i2)].push_back(t);
            edge2tri[makeEdge(i2,i0)].push_back(t);
        }

        // 2) Edge loop: flag edges using midpoint projection + sizing
        std::unordered_map<EdgeKey, char, EdgeKeyHash> edgeFlag;
        edgeFlag.reserve(edge2tri.size());

        for (const auto& kv : edge2tri) {
            const EdgeKey e = kv.first;
            const int a = e.a, b = e.b;

            const double L = edgeLen2D(mesh.V, a, b);
            const Eigen::Vector2d mid(
                0.5*(mesh.V(a,0)+mesh.V(b,0)),
                0.5*(mesh.V(a,1)+mesh.V(b,1))
            );

            // Use corrected distance (upper periodic + lower(+18) periodic)
            const auto proj = projectToBladeTwoPeriodicY_WithLowerShift(
                projector, blade, mid, Ly, kLowerYOffset
            );

            const double hDes = sizeFun(proj.dist, proj.xProj.x());

            edgeFlag[e] = (L > alpha * hDes) ? 1 : 0;
        }

        // 3) If no edges flagged, stop
        int nEdgeFlag = 0;
        for (const auto& kv : edgeFlag) nEdgeFlag += (kv.second ? 1 : 0);
        if (nEdgeFlag == 0) break;

        // 4) Conformity closure (RED-GREEN):
        //    If an edge is split, refine all incident triangles (prevents hanging nodes).
        std::vector<char> triRef(Ne, 0);

        auto isFlagged = [&](const EdgeKey& e)->bool {
            auto it = edgeFlag.find(e);
            return (it != edgeFlag.end() && it->second);
        };

        for (const auto& kv : edge2tri) {
            const EdgeKey& e = kv.first;
            if (!isFlagged(e)) continue;

            for (int t : kv.second) {
                triRef[t] = 1;
            }
        }

        // // Debug
        int nTri = std::count(triRef.begin(), triRef.end(), 1);
        std::cout << "[refine it " << it << "] triRef=" << nTri
                << " (" << 100.0*nTri/Ne << "%)\n";
                
        // 5) Build midpoint nodes for all split edges (unique per edge)
        std::unordered_map<EdgeKey, int, EdgeKeyHash> edgeMidIdx;
        edgeMidIdx.reserve(edgeFlag.size());

        std::vector<Eigen::Vector2d> newPts;
        newPts.reserve(edgeFlag.size());

        for (const auto& kv : edgeFlag) {
            if (!kv.second) continue;

            const int a = kv.first.a, b = kv.first.b;
            const Eigen::Vector2d mid(
                0.5*(mesh.V(a,0)+mesh.V(b,0)),
                0.5*(mesh.V(a,1)+mesh.V(b,1))
            );

            const int idx = static_cast<int>(mesh.V.rows() + newPts.size());
            edgeMidIdx[kv.first] = idx;
            newPts.push_back(mid);
        }

        // append new nodes
        if (!newPts.empty()) {
            Eigen::MatrixXd Vnew(mesh.V.rows() + (int)newPts.size(), 2);
            Vnew.topRows(mesh.V.rows()) = mesh.V;
            for (int i=0; i<(int)newPts.size(); ++i) {
                Vnew(mesh.V.rows()+i,0) = newPts[i].x();
                Vnew(mesh.V.rows()+i,1) = newPts[i].y();
            }
            mesh.V.swap(Vnew);
        }

        // 6) Refine triangles (RED-GREEN refinement)
        //    ns=0 : keep
        //    ns=1 : split into 2
        //    ns=2 : split into 3
        //    ns=3 : split into 4 (red)
        std::vector<Eigen::Vector3i> Eout;
        Eout.reserve(mesh.E.rows() * 4);

        auto hasMid = [&](int i, int j)->bool {
        return edgeMidIdx.find(makeEdge(i,j)) != edgeMidIdx.end();
        };


        auto midIndex = [&](int i, int j) -> int {
            const EdgeKey e = makeEdge(i,j);
            auto it = edgeMidIdx.find(e);
            if (it == edgeMidIdx.end()) {
                std::cerr << "[ERROR] Missing midpoint for flagged edge (" << e.a << "," << e.b << ")\n";
                throw std::out_of_range("edgeMidIdx missing edge midpoint");
            }
            return it->second;
        };

        for (int t = 0; t < Ne; ++t) {
            const int i0 = mesh.E(t,0), i1 = mesh.E(t,1), i2 = mesh.E(t,2);

            // If triangle not marked, keep it
            if (!triRef[t]) {
                Eout.emplace_back(i0,i1,i2);
                continue;
            }

            const bool s01 = hasMid(i0,i1);
            const bool s12 = hasMid(i1,i2);
            const bool s20 = hasMid(i2,i0);
            const int  ns  = int(s01) + int(s12) + int(s20);

            if (ns == 0) {
                // safety: triRef said refine, but no split edges exist
                Eout.emplace_back(i0,i1,i2);
                continue;
            }

            if (ns == 3) {
                // RED: 4 triangles
                const int m01 = midIndex(i0,i1);
                const int m12 = midIndex(i1,i2);
                const int m20 = midIndex(i2,i0);

                Eout.emplace_back(i0,  m01, m20);
                Eout.emplace_back(m01, i1,  m12);
                Eout.emplace_back(m20, m12, i2);
                Eout.emplace_back(m01, m12, m20);
                continue;
            }

            if (ns == 1) {
                // GREEN: split along the single bisected edge -> 2 triangles
                if (s01) {
                    const int m01 = midIndex(i0,i1);
                    Eout.emplace_back(i0,  m01, i2);
                    Eout.emplace_back(m01, i1,  i2);
                } else if (s12) {
                    const int m12 = midIndex(i1,i2);
                    Eout.emplace_back(i1,  m12, i0);
                    Eout.emplace_back(m12, i2,  i0);
                } else { // s20
                    const int m20 = midIndex(i2,i0);
                    Eout.emplace_back(i2,  m20, i1);
                    Eout.emplace_back(m20, i0,  i1);
                }
                continue;
            }

            // ns == 2
            // GREEN: two edges split -> 3 triangles
            // Case A: s01 & s12 (unsplit edge is i2-i0)
            if (s01 && s12) {
                const int m01 = midIndex(i0,i1);
                const int m12 = midIndex(i1,i2);

                Eout.emplace_back(i1,  m12, m01); // small tri at i1
                Eout.emplace_back(i0,  m01, i2);  // split quad
                Eout.emplace_back(i2,  m01, m12);
            }
            // Case B: s12 & s20 (unsplit edge is i0-i1)
            else if (s12 && s20) {
                const int m12 = midIndex(i1,i2);
                const int m20 = midIndex(i2,i0);

                Eout.emplace_back(i2,  m20, m12); // small tri at i2
                Eout.emplace_back(i1,  m12, i0);
                Eout.emplace_back(i0,  m12, m20);
            }
            // Case C: s20 & s01 (unsplit edge is i1-i2)
            else { // (s20 && s01)
                const int m20 = midIndex(i2,i0);
                const int m01 = midIndex(i0,i1);

                Eout.emplace_back(i0,  m01, m20); // small tri at i0
                Eout.emplace_back(i2,  m20, i1);
                Eout.emplace_back(i1,  m20, m01);
            }
        }

        mesh.E.resize((int)Eout.size(), 3);
        for (int i = 0; i < (int)Eout.size(); ++i) mesh.E.row(i) = Eout[i];


        // 7) Update boundary blocks (+snap only on blade blocks, using forced upper/lower)
        std::vector<char> snapped(mesh.V.rows(), 0);

        for (auto& blk : mesh.B) {

            const BladeBlockType btype =
                classifyBladeBoundaryBlock(mesh.V, blk.edges, blade, projector, Ly);

            const bool isBlade = (btype != BladeBlockType::None);

            std::vector<Eigen::Vector2i> Bout;
            Bout.reserve(blk.edges.rows()*2);

            for (int r = 0; r < blk.edges.rows(); ++r) {
                const int a = blk.edges(r,0);
                const int b = blk.edges(r,1);
                const EdgeKey e = makeEdge(a,b);

                const auto itMid = edgeMidIdx.find(e);
                if (itMid == edgeMidIdx.end()) {
                    Bout.emplace_back(a,b);
                    continue;
                }

                const int m = itMid->second;

                if (isBlade && !snapped[m]) {
                    const Eigen::Vector2d pm(mesh.V(m,0), mesh.V(m,1));

                    ProjectionResult proj;
                    if (btype == BladeBlockType::Upper) {
                        proj = projectToBladePeriodicYForced(projector, blade, pm, Ly, 0);
                    } else if (btype == BladeBlockType::Lower) {
                        proj = projectToBladePeriodicYForced(projector, blade, pm, Ly, 1);
                    } else {
                        // should not happen because isBlade checked, but keep safe
                        proj = ProjectionResult{};
                    }

                    // optional debug (first 10 snaps)
                    static int dbgCount = 0;
                    if (dbgCount < 10) {
                        std::cout << "[DEBUG] snap m=" << m
                                  << " blk=" << blk.name
                                  << " btype=" << int(btype)
                                  << " pm=(" << pm.x() << "," << pm.y() << ")"
                                  << " proj=(" << proj.xProj.x() << "," << proj.xProj.y() << ")"
                                  << " dist=" << proj.dist
                                  << " curveId=" << proj.curveId
                                  << "\n";
                        ++dbgCount;
                    }

                    mesh.V(m,0) = proj.xProj.x();
                    mesh.V(m,1) = proj.xProj.y();
                    snapped[m] = 1;
                }

                Bout.emplace_back(a,m);
                Bout.emplace_back(m,b);
            }

            blk.edges.resize((int)Bout.size(), 2);
            for (int i=0; i<(int)Bout.size(); ++i)
                blk.edges.row(i) = Bout[i];
        }
        // 8) Smooth interior nodes only (Eq. 1)
        smoothInterior(mesh, smoothIters, omega);

        // Smoothing metric: average edge length before/after
        auto avgEdgeLen = [&](const Eigen::MatrixXd& V, const Eigen::MatrixXi& E){
            double s=0; long long m=0;
            for (int t=0;t<E.rows();++t){
                int i0=E(t,0),i1=E(t,1),i2=E(t,2);
                s += edgeLen2D(V,i0,i1)+edgeLen2D(V,i1,i2)+edgeLen2D(V,i2,i0);
                m += 3;
            }
            return s/double(m);
        };

        double Lbefore = avgEdgeLen(mesh.V, mesh.E);
        smoothInterior(mesh, smoothIters, omega);
        double Lafter  = avgEdgeLen(mesh.V, mesh.E);
        std::cout << "[smooth] avgEdgeLen " << Lbefore << " -> " << Lafter << "\n";
        // Smoothing metric: average edge length before/after



        // 9) Re-snap blade boundary nodes to spline geometry
        snapBladeBoundaries(mesh, blade, projector, Ly);

        // HARD ASSERT: must have both blade blocks
        assertBladeBlocksPresent(mesh, blade, projector, Ly);
        assertBladeSnapOK(mesh, blade, projector, Ly, 1e-10);

        // sanity: blade boundary nodes should lie on geometry (dist ~ 0)
        double maxDist = 0.0;
        int cnt = 0;

        for (const auto& blk : mesh.B) {
            const BladeBlockType btype =
                classifyBladeBoundaryBlock(mesh.V, blk.edges, blade, projector, Ly);

            if (btype == BladeBlockType::None) continue;

            std::vector<int> ids;
            ids.reserve(blk.edges.rows()*2);
            for (int r=0; r<blk.edges.rows(); ++r) { ids.push_back(blk.edges(r,0)); ids.push_back(blk.edges(r,1)); }
            std::sort(ids.begin(), ids.end());
            ids.erase(std::unique(ids.begin(), ids.end()), ids.end());

            const int forceId = (btype == BladeBlockType::Upper) ? 0 : 1;
            for (int id : ids) {
                const Eigen::Vector2d p(mesh.V(id,0), mesh.V(id,1));
                auto pr = projectToBladePeriodicYForced(projector, blade, p, Ly, forceId);
                maxDist = std::max(maxDist, pr.dist);
                cnt++;
            }
        }
        std::cout << "[snap check] blade nodes=" << cnt << " maxDist=" << maxDist << "\n";
        // sanity: blade boundary nodes should lie on geometry (dist ~ 0)
        for (const auto& blk : mesh.B) {
            auto btype = classifyBladeBoundaryBlock(mesh.V, blk.edges, blade, projector, Ly);
            std::cout << "[BLK] name=" << blk.name
                    << " edges=" << blk.edges.rows()
                    << " btype=" << int(btype) << "\n";
        }

        snapBladeBoundaries(mesh, blade, projector, Ly);
        verifyBladeSnap(mesh, blade, projector, Ly, 1e-6);

    }

    return mesh;
}

} // namespace mesh
